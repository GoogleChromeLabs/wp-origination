<!-- DO NOT EDIT THIS FILE; it is auto-generated from readme.txt -->
# Sourcery

Determine the source of where things come from in WordPress whether slow code, inefficient queries, or bad markup.

**Contributors:** [westonruter](https://profiles.wordpress.org/westonruter)  
**Tags:** [performance](https://wordpress.org/plugins/tags/performance)  
**Requires at least:** 4.9  
**Tested up to:** 5.1-alpha  
**Stable tag:** trunk (master)  
**License:** [GNU General Public License v2 (or later)](https://www.gnu.org/licenses/gpl-2.0.html)  
**Requires PHP:** 5.6  

[![Built with Grunt](https://cdn.gruntjs.com/builtwith.svg)](http://gruntjs.com) 

## Description ##

There are a lot of plugins and themes out there in the WordPress ecosystem. Many of them are not written with performance in mind, either in the database queries they make or the markup they add to the frontend. Also, because themes and plugins can hook into any part of the WordPress execution lifecycle it is difficult to identify which is responsible for a performance problem. This is what the Sourcery plugin assists with: it identifies the source for where things come from in WordPress whether slow code, inefficient queries, or bad markup. ("Sourcery" is a pun on "sorcery" and "source".)

Most of the ideas in this plugin were first prototyped in the [AMP plugin](https://github.com/ampproject/amp-wp). It includes a sanitizer to remove any markup that is not valid, but it also needs to inform the site owner of where the offending markup came from in the first place. In order to provide this information, the AMP plugin adds wrappers around actions, filters, blocks, shortcodes, widgets, and embeds to annotate the output with HTML comments both preceding and following, similar to Gutenberg block comments. With these HTML comment annotations in place, when invalid AMP markup is encountered, the source(s) responsible for it can be determined by just looking all of the annotation comments that are open.

This plugin takes the ideas from the AMP plugin and generalizes them for use by other plugins, including the AMP plugin itself. One key use for these HTML source annotations is for Lighthouse to be able to indicate the theme/plugin that is responsible for problems identified by audits, whether they be for performance, accessibility, best practices, or SEO.

Bonus: This plugin also outputs `Server-Timing` headers to tally how much time was spent on core, themes, and plugins.

In order to invoke the plugin's behavior, first enable `WP_DEBUG` mode in the `wp-config.php`; also enable `SAVEQUERIES` if you want to include the SQL queries performed (which will be displayed if you are an admin).

Then access a site frontend with `?sourcery` in the URL. For example, `https://example.com/2019/08/07/foo/?sourcery`. This will then cause the plugin to annotate the page output with Gutenberg-inspired HTML comments to annotate WordPress's execution. You'll see comments like the following (here with some added formatting):

<pre><code>&lt;!-- sourcery
{
    "callback": "rel_canonical",
    "duration": 0.0026450157165527344,
    "id": 242,
    "name": "wp_head",
    "priority": 10,
    "source": {
        "file": "/app/public/core-dev/src/wp-includes/link-template.php",
        "name": "wp-includes",
        "type": "core"
    }
}
--&gt;
&lt;link rel="canonical" href="https://example.com/2019/08/07/foo/" /&gt;
&lt;!-- /sourcery {"id":242,"name":"wp_head","priority":10,"callback":"rel_canonical"} --&gt;
</code></pre>

With such annotation comments in place, to determine annotation stack for a given DOM node you then select a node in DevTools and then paste the following JS code into the console (see second secreenshot):

```js
(( node ) => {
    const openCommentPrefix = ' sourcery ';
    const closeCommentPrefix = ' /sourcery ';

    const invocations = {};
    const expression = `
        preceding::comment()[
            starts-with( ., "${openCommentPrefix}" )
            or
            ( starts-with( ., "[" ) and contains( ., "<!--${openCommentPrefix}" ) )
            or
            starts-with( ., "${closeCommentPrefix}" )
        ]`;
    const xPathResult = document.evaluate( expression, node, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null );
    const annotationStack = [];
    for ( let i = 0; i < xPathResult.snapshotLength; i++ ) {
        let commentText = xPathResult.snapshotItem( i ).nodeValue;

        // Account for IE conditional comments which result in comment nodes that look like:
        // [if lt IE 9]><!-- sourcery {...
        const conditionalCommentOffset = commentText.indexOf( `<!--${openCommentPrefix}` );
        if ( conditionalCommentOffset !== -1 ) {
            commentText = commentText.substr( conditionalCommentOffset + 4 );
        }

        const isOpen = commentText.startsWith( openCommentPrefix );
        const data = JSON.parse( commentText.substr( isOpen ? openCommentPrefix.length : closeCommentPrefix.length ) );
        if ( isOpen ) {
            if ( data.id ) {
                invocations[ data.id ] = data;
            }
            if ( data.invocations ) {
                for ( const id of data.invocations ) {
                    annotationStack.push( invocations[ id ] );
                }
            } else {
                annotationStack.push( data );
            }
        } else {
            if ( data.invocations ) {
                for ( const id of [...data.invocations].reverse() ) {
                    const popped = annotationStack.pop();
                    if ( id !== popped.id ) {
                        throw new Error( 'Unexpected closing annotation comment for ref: ' + commentText );
                    }
                }
            } else {
                const popped = annotationStack.pop();
                if ( data.id !== popped.id ) {
                    throw new Error( 'Unexpected closing annotation comment: ' + commentText );
                }
            }
        }
    }
    return annotationStack;
})( $0 );
```

While this is also sent via `Server-Timing` headers, you can determine the amount of time spent by core, theme, and plugins with the following JS code:

```js
(() => {
    const durations = {};
    const openCommentPrefix = ' sourcery ';
    const expression = `comment()[ starts-with( ., "${openCommentPrefix}" ) ]`;
    const result = document.evaluate( expression, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null );

    for ( let i = 0; i < result.snapshotLength; i++ ) {
        const commentText = result.snapshotItem( i ).nodeValue;
        const data = JSON.parse( commentText.substr( openCommentPrefix.length ) );

        const key = data.source.type + ':' + data.source.name;
        if ( ! ( key in durations ) ) {
            durations[ key ] = 0.0;
        }
        durations[ key ] += data.duration;

    }
    return durations;
})();
```

## Screenshots ##

### Server-Timing headers are sent when sourcery is running.

![Server-Timing headers are sent when sourcery is running.](wp-assets/screenshot-1.png)

### Determine where markup in the page comes from.

![Determine where markup in the page comes from.](wp-assets/screenshot-2.png)

## Changelog ##

### 0.1 (Unreleased) ###
...


